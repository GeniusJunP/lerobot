# Asynchronous Inference

In [SmolVLA](https://huggingface.co/papers/2506.01844) we introduced a new way to run inference on real-world robots, **decoupling action prediction from action execution**.
In this tutorial, we'll show how to use asynchronous inference (_async inference_) with SmolVLA, and all the policies supported by LeRobot.

With *async inference* your robot keeps acting while the policy server is already busy computing the next chunk of actions—eliminating "wait-for-inference" lag and unlocking smoother, more reactive behaviours.
This is fundamentally different from synchronous inference (sync), where the robot stays idle while the policy computes the next chunk of actions.


**What you'll learn:**
1. Why asynchronous inference matters and how it compares to the traditional sequential loop.
2. How to spin-up a `PolicyServer` and connect a `RobotClient` from the same machine, or over the network.
3. How to tune key parameters (`actions_per_chunk`, `chunk_size_threshold`) for your robot and policy.

If you get stuck, hop into our [Discord community](https://discord.gg/s3KuuzsPFb)

## Async vs. synchronous inference

Synchronous inference relies on interleaving action chunk prediction and action execution. This inherently results in *idle frames*, frames where the robot awaits idle the policy's output: a new action chunk. This results in evident real-time lags, where the robot simply stops acting due to the lack of available actions.

<p align="center">
  <img src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/async-inference/sync.png" width="80%"></img>
</p>
<p align="center"><i>Synchronous inference</i> makes the robot idle while the policy is computing the next chunk of actions.</p>

On the contrary, async inference overlaps action planning and execution, resulting in (1) higher adaptability and, most importantly (2) no idle frames.
Crucially, with async inference, the next action chunk is computed *before* the current one is exhausted, resulting in no idleness. Adaptability is ensured by aggregating the different action chunks on overlapping portions, obtaining an up-to-date plan.

<p align="center">
  <img src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/async-inference/async.png" width="80%"></img>
</p>
<p align="center"><i>Asynchronous inference</i> results in no idleness because the next chunk is computed before the current chunk is exhausted.</p>

---

## Getting started with async inference

You can read more information on asynchronous inference on the in-detail blogpost. Here, we report a getting started guide meant to help you setup and run asynchronous inference in your setup.

Just install `lerobot` with the `smolvla` option to install the extra dependencies (`grpcio==1.71.0`) required to run async inference.

```bash
pip install -e ".[smolva]"
```

---

## 1 Start the Policy Server

Policy servers are wrappers around a `PreTrainedPolicy` interfacing them with observations coming from a robot client.
Policy servers are initialized as empty containers which are populated with the requested policy specified in the initial handshake between the robot client and the policy server.
As such, spinning up a policy server is as easy as specifying the host address and port. If you're running the policy server on the same machine as the robot client, you can use `localhost` as the host address.

<hfoptions id="start_policy_server">
<hfoption id="Command">
```bash
python -m lerobot.scripts.server.policy_server \
    --host="localhost" \
    --port=8080
```
</hfoption>
<hfoption id="API example">
```python
from lerobot.scripts.server.configs import PolicyServerConfig
from lerobot.scripts.server.policy_server import serve

config = PolicyServerConfig(
    host="localhost",
    port=8080,
)
serve(config)
```
</hfoption>
</hfoptions>

This listens on `localhost:8080` for an incoming connection from the associated`RobotClient`, which will specify the policy to run during handshake.

---

## 2 Launch the Robot Client

`RobotClient` is a wrapper around a `Robot` instance, which `RobotClient` connects to the (possibly remote) `PolicyServer`.
The `RobotClient` streams observations to the `PolicyServer`, and receives action chunks obtained running inference on the server (which we assume to have better computational resources than the robot controller).

<hfoptions id="start_robot_client">
<hfoption id="Command">
```bash
python -m lerobot.scripts.server.robot_client \
    --server_address="localhost:8080" \
    --robot.type="so100_follower" \  # <-- change this to your robot's type
    --robot.port="/dev/tty.usbmodem585A0076841" \  # <-- change this to your robot's port (find_port.py)
    --robot.id="follower_so100" \  # id of the robot
    --robot.cameras="{"laptop": {"index_or_path": 0, "width": 1920, "height": 1080, "fps": 30}}" \  # cameras of the robot. They must match the camera keys expected by the policy
    --policy.device="mps" \  # device to run the policy on
    --chunk_size_threshold=0.6 \  # Threshold for the chunk size
    --task="Fold my T-shirt"  # Textual description of the task to run the model runs
    --policy.type=... \  # Change to the policy type to run
    --policy.pretrained_name_or_path=... \  # path of the policy or pretrained name if available on the Hub
```
</hfoption>
<hfoption id="API example">
```python
import threading
import time
from lerobot.robots.so100_follower import SO100FollowerConfig, SO100Follower
from lerobot.cameras.opencv.configuration_opencv import OpenCVCameraConfig
from lerobot.scripts.server.configs import RobotClientConfig
from lerobot.scripts.server.robot_client import RobotClient
from lerobot.scripts.server.helpers import TimedObservation, map_robot_keys_to_lerobot_features

# 1. Create the robot instance
"""Check out the cameras available in your setup by running `python lerobot/find_cameras.py`"""
camera_cfg = {"laptop": OpenCVCameraConfig(index_or_path=0, width=1920, height=1080, fps=30)}
robot_cfg = SO100FollowerConfig(port="/dev/tty.usbmodem585A0076841", id="follower_so100", cameras=camera_cfg)
robot = SO100Follower(robot_cfg)

# 2. Map between the raw robot features and the lerobot format
lerobot_features = map_robot_keys_to_lerobot_features(robot)

# 3. Create client configuration
client_cfg = RobotClientConfig(
    robot=robot,
    server_address="localhost:8080",
    policy_device="mps",
    lerobot_features=lerobot_features,
    chunk_size_threshold=0.6,
    lerobot_features=lerobot_features,
    policy_type=...,
    pretrained_name_or_path=...,
)

# 4. Create and start client
client = RobotClient(client_cfg)

# 5. Specify the task
task = ...

if client.start():
    def make_observation() -> TimedObservation:
        observation = client.robot.get_observation()
        observation["task"] = task

        return TimedObservation(
            timestamp=time.time(),
            observation=observation,
            timestep=max(client.latest_action, 0),
        )

    # Start action receiver thread
    action_receiver_thread = threading.Thread(target=client.receive_actions, daemon=True)
    action_receiver_thread.start()

    try:
        # Run the control loop
        client.control_loop(make_observation)
    except KeyboardInterrupt:
        client.stop()
        action_receiver_thread.join()
```
</hfoption>
</hfoptions>

The following two parameters are key in every setup:
| Hyperparameter | Default | What it does |
|------|---------|-------------|
| `actions_per_chunk` | 50 | How many actions the policy outputs at once.  Typical values: 10-50. |
| `chunk_size_threshold` | 0.7 | When the queue is ≤ 50 % full, the client sends a fresh observation.  Value in [0, 1]. |


Different values of `actions_per_chunk` and `chunk_size_threshold` do result in different behaviours.
On the one hand, increasing the value of `actions_per_chunk` will result in reducing the likelihood of ending up with no actions to execute, as more actions will be available when the new chunk is computed.
However, larger values of `actions_per_chunk` might also result in less precise actions, due to the compounding errors consequent to predicting actions over longer timespans.

On the other hand, increasing the value of `chunk_size_threshold` will result in sending out to the `PolicyServer` observations for inference more often, resulting in a larger number of updates action chunks, overlapping on significant portions. This results in high adaptability, in the limit predicting one action chunk for each observation, which is in turn only marginally consumed while a new one is produced.
This option does also put more pressure on the inference pipeline, as a consequence of the many requests. Conversely, values of `chunk_size_threshold` close to 0.0 collapse to the synchronous edge case, whereby new observations are only sent out whenever the current chunk is exhausted.

We found the default values of `actions_per_chunk` and `chunk_size_threshold` to work well in the experiments we developed for the [SmolVLA paper](https://huggingface.co/papers/2506.01844), but recommend experimenting with different values to find the best fit for your setup.

### Tuning async inference for your setup

1. **Choose your hardware right.**  [PI0](https://huggingface.co/lerobot/pi0) occupies 14GB of memory at inference time, while [SmolVLA](https://huggingface.co/lerobot/smolvla_base) requires only ~2GB. You should identify the best computational resource for your use case keeping in mind smaller policies require less computational resources. The combination of policy and device used (CPU-intensive, using MPS, or the number of CUDA cores on a given NVIDIA GPU) directly impacts the average inference latency you should expect.
2. **Adjust your `fps` based on inference latency.** While the server generates a new action chunk, the client is not idle and is stepping through its current action queue. If the two processes happen at fundamentally different speeds, the client might end up with an empty queue. As such, you should reduce your fps if you consistently run out of actions in queue.
3. **Adjust `chunk_size_threshold`**.
   - Values closer to `0.0` result in almost sequential behavior. Values closer to `1.0` → send observation every step (more bandwidth, relies on good world-model).
   - We found values around 0.5-0.6 to work well. If you want to tweak this, spin up a `RobotClient` passing the `--debug-visualize-queue-size` flag. This will plot the action queue size evolution at runtime, and you can use it to find the value of `chunk_size_threshold` that works best for your setup.

<p align="center">
  <img src="https://huggingface.co/datasets/huggingface/documentation-images/blob/main/async-inference/queues.png" width="80%"></img>
</p>
<p align="center"><i>The action queue size is plotted at runtime when the `--debug-visualize-queue-size` flag is passed, for various levels of `chunk_size_threshold` (`g` in the SmolVLA paper).</i></p>


If you want to discuss this further, hop into our [Discord community](https://discord.gg/s3KuuzsPFb), or open an issue on our [GitHub repository](https://github.com/lerobot/lerobot/issues).
